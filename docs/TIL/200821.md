# 0821 TIL
> #### 3장 콜백을 사용한 비동기 제어 흐름 패턴
> - 3.1 비동기 프로그래밍의 어려움
> - 3.2 일반 JavaScript의 사용

## 1. 비동기 프로그래밍의 어려움
- 익명 함수의 클로저와 인플레이스 정의(in place definitions)는 개발자가 이 함수, 저 함수로 옮겨 다닐 필요 없이 원활하게 프로그래밍을 할 수 있게 한다.
- 모듈화, 재사용성, 유지보수성 같은 특성을 희생시키다 보면 금방 콜백 중첩이 통제되지 않고 확산되고 함수 크기가 커지며 코드의 구성이 엉망이 된다.
  
### 1.1 간단한 웹 스파이더
- 웹 URL을 입력으로 받아 해당 URL의 내용을 로컬 파일로 다운로드 하는 콘솔용 application
- 사용되는 npm 라이브러리: request, mkdirp, slug
```javascript
// spider.js
const request = require('request');
const fs = require('fs');
const mkdirp = require('mkdirp');
const path = require('path');
const utilities = require('./utilities');

function spider(url, callback) {
    const filename = utilities.urlToFilename(url);
    checkFileExist(filename, url, callback)
}

function checkFileExist(filename, url, callback) {
    fs.exists(filename, exists => {
        if (!exists) {
            requestTo(url, callback, filename);
        } else {
            callback(null, filename, false);
        }
    });
}

function requestTo(url, callback, filename) {
    console.log(`Downloading ${url}`);
    request(url, (err, _response, body) => {      //[2]
        if (err) {
            callback(err);
        } else {
            makeDirectory(filename, callback, body);
        }
    });
}

function makeDirectory(filename, callback, body) {
    return mkdirp(path.dirname(filename), err => {    //[3]
        if (err) {
            callback(err);
        } else {
            writeFile(filename, body, callback);
        }
    });
}

function writeFile(filename, body, callback) {
    return fs.writeFile(filename, body, err => { //[4]
        if (err) {
            callback(err);
        } else {
            callback(null, filename, true);
        }
    });
}


spider(process.argv[2], (err, filename, downloaded) => {
  if(err) {
    console.log(err);
  } else if(downloaded){
    console.log(`Completed the download of "${filename}"`);
  } else {
    console.log(`"${filename}" was already downloaded`);
  }
});
```

### 1.2 콜백 헬(The Callback Hell)
- 많은 클로저와 내부 콜백 정의가 코드를 읽기 어렵고 관리하기 어려운 덩어리로 만드는 상황
- 가독성이 심하게 떨어진다.
- 위의 spider.js를 함수로 나눈다고 나눴지만 여전히 읽기가 매우 어렵다.
- 각 스코프에서 사용된 변수 이름의 중복이 발생한다.(변수의 내용을 설명하기 위해 유사하거나 동일한 이름을 사용하기 때문에)

## 2. 일반 JavaScript의 사용
- 가장 일반적인 제어 흐름 패턴 구현 방법

### 2.1 콜백 규칙
- 첫 번째 규칙은 콜백을 정의할 때 함부로 클로저를 사용하지 않는 것이다. 