# 0914 TIL
> - **Node.js 6장 디자인 패턴**
> - 6.5 Adapter(어댑터)
> - 6.6 Strategy(전략)

## 6.5 Adapter 패턴(어댑터)
- 다른 인터페이스를 사용하여 객체의 함수를 액세스할 수 있다.
- 다른 인터페이스를 호출하는 요소들에 의해 사용될 수 있도록 객체를 조정한다.

![어댑터](img/adapter.png)

- 어댑터는 본질적으로 다른 인터페이스를 노출하는 객체(Adaptee)의 wrapper이다.
- 어댑터의 동작이 대상 객체(Adaptee)에 대한 하나 이상의 메서드 호출로 구성될 수 있다.
- 가장 보편적인 기술은 컴포지션이다.
- 어댑터가 대상 객체의 메서드에 대한 중재자 역할을 제공하도록 한다.

### 6.5.1 파일 시스템 API를 통한 LevelUP 사용
- LevelUP API를 가지고 어댑터를 구축하여 core fs 모듈과 호환되는 인터페이스로 변환
- readFile()을 db.get()으로, writeFile()을 db.put()으로 변환
- 결과적으로 간단한 파일 시스템 작업을 위해 LevelUP 데이터베이스를 저장소의 백엔드로 사용할 수 있게 된다.

```javascript
const path = require('path');

module.exports = function createFsAdapter(db) {
    const fs = {};
    fs.readFile = (fileName, options, callback) => {
        if (typeof options === 'function') {
            callback = options;
            options = {};
        } else if (typeof options === 'string') {
            options = {encoding: options};
        }

        db.get(path.resolve(fileName), {
            valueEncoding: options.encoding
        }, (err, value) => {
            if (err) {
                if (err.type === 'NotFoundError') {
                    err = new Error(`ENOENT, open "${fileName}"`);
                    err.code = 'ENOENT';
                    err.errno = 34;
                    err.path = fileName;
                }
                return callback && callback(err);
            }
            callback && callback(null, value);
        });
    }
    fs.writeFile = (fileName, contents, options, callback) => {
        if(typeof options === 'function') {
            callback = options;
            options = {};
        } else if (typeof options === 'string') {
            options = {encoding: options};
        }
    
        db.put(path.resolve(filename), contents, {
            valueEncoding: options.encoding
        }, callback);
    }
    return fs;
}
```

- 완벽하지는 않지만 일반적인(?) 상황에서는 확실히 작업을 수행한다.

```javascript
// fsAdapterTest.js
const fs = require('fs');

fs.writeFile('file.txt', 'Hello!', () => {
    fs.readFile('file.txt', {encoding: 'utf8'}, (err, res) => {
        console.log(res);
    });
});

/// missing.txt 파일을 읽으려고 시도
fs.readFile('missing.txt', {encoding: 'utf8'}, (err, res) => {
    console.log(err);
});
```

- 결과적으로 fs 모듈을 완벽하지는 않은 어댑터로 교체 가능해진다.

```javascript
const levelup = require('level');
const fsAdapter = require('./fsAdapter');
const db = levelup('./fsDB', {valueEncoding: 'binary'});    // fsDB.js는 현재 없음
const fs = fsAdapter(db);
```

- 어댑터를 사용하여 수행한 작업은 LevelUP 데이터베이스에서 수행된 작업으로 변환된다.
- level.js: 브라우저에서 데이터베이스를 실행할 수 있는 LevelUP 어댑터
- 어댑터가 얼마나 중요한 패턴인지는 *8장에서* 다시 확인하라고 함

### 6.5.2 실전에서는 어떻게 사용되는가
- level-filesystem 라이브러리: 위의 예제를 완벽하게 구현하고 있음, LevelUP위에 fs API를 알맞게 구현함

## 6.6 Strategy 패턴(전략)
- Context라 불리는 객체를 사용하여 변수 부분을 상호 교환 가능한 개별 전략이라는 객체들로 추출함으로써 연산 로직의 변형을 지원한다.
- Context는 일련의 알고리즘의 공통 로직을 구현하는 반면, 개별 전략은 입력값, 시스템 구성 혹은 사용자 기본 설정 같은 다양한 요소들을 Context의 동작에 적용할 수 있도록 변경 가능한 부분을 구현한다.
- 개별 전략들은 대개 솔루션 제품군에 속하고, 이들 모두 동일한 인터페이스를 구현한다.

![strategy](img/strategy.png)

### 6.6.1 다중 형식의 환경설정 객체

- **Config 객체 예시**: DB URL, 서버의 listening port 등 application에 의해 사용되는 환경설정 파라미터들을 보관
  - 간단한 인터페이스 제공해야 함
  - 파일과 같은 영구 저장소를 사용한 환경설정을 가져오거나 내보내는 방법 제공해야 함
  - JSON, INI 또는 YAML과 같이 구성을 저장할 수 있는 다른 형식을 지원할 수 있어야 함
- Config 객체가 구성을 직렬화 및 비직렬화 할 수 있는 함수를 이용하여 Config 객체의 변수 부분을 바로 식별해보기

```javascript
// config.js
const fs = require('fs');
const objectPath = require('object-path');  // 점 경로 표기법 라이브러리, 환경설정 속성 접근할 수 있는 get(), set() 제공

class Config {
    constructor(strategy) {
        this.data = {};
        this.strategy = strategy;
    }

    get(path) {
        return objectPath.get(this.data, path);
    }

    set(path, value) {
        return objectPath.set(this.data, path, value);
    }

    read(file) {
        console.log(`Deserializing from ${file}`);
        this.data = this.strategy.deserialize(fs.readFileSync(file, 'utf-8'));
    }

    save(file) {
        console.log(`Serializing to ${file}`);
        fs.writeFileSync(file, this.strategy.serialize(this.data));
    }
}
module.exports = Config;
```

